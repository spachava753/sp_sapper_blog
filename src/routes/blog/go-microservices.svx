---
title: Go Microservices
date: 2021-01-24T18:24:27.136Z
link: go-microservices
abstract: Writing microservices is hard. There are lots of application concerns that we have to keep in mind like rate limiting, circuit breaking, retries, logging, metrics collection, feature flags, etc. Frameworks like Spring Boot, Ruby on Rails, and Django have generally helped with this problem for developers, but what does Go have?
---

<script>
    import StarCount from '../../components/StarCount.svelte';
    import Checkbox from '../../components/Checkbox.svelte';
    import Blockquote from '../../components/Blockquote.svelte';
</script>

<Checkbox>Talk about what microservices are</Checkbox>
<Checkbox>Talk about writing microservices in 2020</Checkbox>
<Checkbox>Talk about some solutions</Checkbox>
<Checkbox>Talk about go-kit</Checkbox>


Writing microservices is hard. Doesn't matter what language, going from monolith to microservices means introducing more moving parts, more possibilities for failure, yet in order to scale effectively, they are a necessary evil. According to this post: the definition microservices is this:
<Blockquote>Microservices are a style of software architecture that involves delivering systems as a set of very small, granular, independent collaborating services</Blockquote>

What the heck does that mean? Well, lets break it down.
<Blockquote>Microservices are a style of software architecture...</Blockquote>

Okay, so microservices is way to build software, just like monoliths are another way to build software. In that case, microservices don't refer to any one programming language or platform.

<Blockquote>...that involves delivering systems...</Blockquote>

It looks like creating software isn't enough. We also have to figure out how to deliver or make it available to our users. Who woulda thunk?

<Blockquote>...as a set of very small, granular, independent collaborating services</Blockquote>

This is the most important part. Microservices, true to its name, means building small, purposeful services that are really meant to a single task. What this task is and the scope of this task is up to the creator of microservices but like Unix philosophy, microservices are meant to do one thing each, and do it well. Of course, each microservices can't achieve much in isolation. as such, they should also collaborate.

Okay. To sum it all up, microservices is a style of building and delivering software that does one thing well and collaborates with other microservices. Sounds good. üëç

Thank you for reading! Be sure come back for the next post...I'm just joking üòÖ. There is still much more left to think about. 

Lets start with the "collaboration" part. How are your microservices supposed to communicate? Based on your system, perhaps a message bus or a pub sub makes more sense. Maybe you fancy GRPC, or you just want good all REST. Heck, it could be a conglomeration of all of these! So we decided on a means of communication between our microservices. Are we done?

Wait! What about observability? When we had monolithic architecture, we knew where all requests go the same place, but now that our code is split into separate units, we can't keep track of where each request ends up and what services it uses! What if some requests are failing? How do we know what service caused to request to fail? Often, a single microservices might talk to not just one, but *multiple* services, so it can get pretty difficult trace where each request goes.

Lets assume that we have taken care of observability, now its time to talk about monitoring. What's the difference between observability and monitoring? Observability allows to obtain insights into how requests flow through our system. Monitoring allows us to obtain metrics about how each of our services are performing, metrics like: RPS, CPU usage, Memory usage, Number of Bad requests, Average duration, and much more. Basically, if it is possible to monitor it, its not bad idea to monitor it ü§∑‚Äç‚ôÇÔ∏è.

We're still missing something...oh yeah! Scalability! One of the most important reasons to go through all this trouble in the first place. If we used a monolithic architecture, scaling that service usually meant acquiring bigger specs like more memory, more cpu cores, and more network bandwidth. However, there is a limit to this, and we get diminishing returns as we keep upgrading. However, if we split our service into microservices, we scale individual microservices to handle load needed. However, we might still hit a limit for one or more microservices, after all, the problem of getting more and more expensive hardware hasn't gone away. What a troubling issue! 

Hm ü§îü§î, what if...nah...maybe...hear me out. Lets run... multiple instances of microservices. I know, I know, it sounds insane, but stay with me. If we were able to run multiple instances, or copies of a single microservice, this would allow to simple acquire more servers instead of dishing out cash for high-spec hardware. As Google calls it, we could run on commodity hardware, that is, buy a couple of used desktops off Ebay, connect them together, and run our microservices on them. Wonderfulü§ó! But wait, theres more! How do the other services know where to find our running services? After all, there are multiple copies running at different locations. This is a well known problem called service discovery. But how do we solve this problem?

Besides these concerns, we also have others like encrypting connections between microservices for security, figuring out how to deploy our microservices after we create a new version, setting up a central location for all of our microservices configuration, load-balancing and much more. This whole microservices thing is really starting to daunting...

As it turns out, people realized that this whole microservices thing can only work if all of these concerns were addressed. One solution to this problem is Netflix's OSS stack. It is Java-based, and solves the problems mentioned above, like service discovery, central configuration, monitoring, etc. It's most often used with Spring Cloud, which is a set of libraries built to work with the (in?)famous Spring framework. We still haven't addressed one issue: deployment! How are ever supposed to actually deploy our microservices to our Ebay servers?! I guess we can use ssh or ansible or something üò¶.

